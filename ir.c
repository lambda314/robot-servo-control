#include "ir.h"
#include "uart.h"

//本解码程序适用于NEC的upd6121及其兼容芯片的解码，支持大多数遥控器 实验板采用22.1184MHZ晶振

 
uchar IrCode[4];        			//储存用户码、用户反码与键数据码、键数据反码
uint  LowTime,HighTime; 			//储存高、低电平的宽度 


void int0_init(void)
{
    IP |= 0x01;						//PX0=1;
	IPH|= 0x01;					    //PX0H=1;PX0H:PX0=1:1;外部中断0为最高优先级中断（优先级3）
	IT0 = 1;                        //set INT0 int type (1:Falling 0:Low level)
    EX0 = 1;                        //enable INT0 interrupt
    EA = 1;                         //open global interrupt switch
	IR = 1;

}
/**********************************************<+><+><+><+><+>★【robot】★<+><+><+><+><+>************************************************
函数名称：decode_ir
函数功能：对4个字节的用户码和键数据码进行解码
输入参数：无
输出参数：bit 解码正确，返回1，否则返回0
***********************************************<<<<<<<<<<<<<<<★【robot】★>>>>>>>>>>>>>>>************************************************/
bit decode_ir(void)        
{
    
	uchar  i,j;
	uchar temp;    									//储存解码出的数据
	for(i=0;i<4;i++)      							//连续读取4个用户码和键数据码
	{
		for(j=0;j<8;j++)  							//每个码有8位数字
		{
			temp=temp>>1;  							//temp中的各数据位左移一位，因为先读出的是低位数据									
			TH1=0;         							//定时器1清0
			TL1=0;         							//定时器1清0
			TR1=1;         							//开启定时器T
			while(!IR); 							//如果是低电平就等待
			TR1=0;         							//关闭定时器T0
			LowTime=TH1*256+TL1;					//保存低电平宽度
			if((LowTime<922)||(LowTime>1100))		//Low level 5~6ms
		    	return 0;        					//如果低电平长度不在合理范围，则认为出错，停止解码			
			TH1=0;         							//定时器1清0
			TL1=0;         							//定时器1清0
			TR1=1;         							//开启定时器T1
			while(IR);   							//如果是高电平就等待		   
			TR1=0;        							//关闭定时器T0
			HighTime=TH1*256+TL1;   				//保存高电平宽度
			if((HighTime>932)&&(HighTime<1132))   	//如果高电平时间在560微秒左右，即计数560／1.085＝516次	 560/0.5425=1032
	       		temp=temp&0x7f;       				//(520-100=420, 520+100=620)，则该位是0
			if((HighTime>2897)&&(HighTime<3297)) 	//如果高电平时间在1680微秒左右，即计数1680／1.085＝1548次 1680/0.5425=3097
	       		temp=temp|0x80;       				//(1550-250=1300,1550+250=1800),则该位是1
		}  			            
		IrCode[i]=temp;								//将解码出的字节值储存在a[i]																					 
	}  				 		 
	if(IrCode[2]=~IrCode[3])  						//验证键数据码和其反码是否相等,一般情况下不必验证用户码
		return 1;     								//解码正确，返回1
}

 /**********************************************<+><+><+><+><+>★【robot】★<+><+><+><+><+>************************************************
函数功能：红外线触发的外中断处理函数
***********************************************<<<<<<<<<<<<<<<★【robot】★>>>>>>>>>>>>>>>************************************************/
void Int0(void) interrupt 0
{
	uchar i;
	EX0=0;      									//关闭外中断1，不再接收二次红外信号的中断，只解码当前红外信号
	TH1=0;      									//定时器T1的高8位清0
	TL1=0;      									//定时器T1的低8位清0
	TR1=1;	    									//开启定时器T1	 
	while(!IR);          							//如果是低电平就等待，给引导码低电平计时
	TR1=0;                							//关闭定时器T0     
	LowTime=TH1*256+TL1;  							//保存低电平时间
	if((LowTime>7795)&&(LowTime<17090))	 			//17090
	{
		TH1=0;      								//定时器T1的高8位清0
		TL1=0;      								//定时器T1的低8位清0
		TR1=1;	    								//开启定时器T1
		while(IR);  								//如果是高电平就等待，给引导码高电平计时
		TR1=0;       								//关闭定时器T0
		HighTime=TH1*256+TL1;						//保存引导码的高电平长度
		if((HighTime>7795)&&(HighTime<8795))
		{
													//如果是引导码,就开始解码,否则放弃,引导码的低电平计时
													//次数＝9000us/0.5425=16590, 判断区间:17090-500＝16590，17090＋500＝17590;4500/0.5425=8295
			//if(decode_ir())							// 执行遥控解码功能
			{	
				//for(i=0;i<4;i++)
				//	send1_char(IrCode[i]);				
			}
		}
	}
	EX0=1;   										//开启外中断EX1
} 
